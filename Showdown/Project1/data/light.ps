////////////////////////////////////////////////////////////////////////////////
// Filename: light.ps
////////////////////////////////////////////////////////////////////////////////


/////////////
// DEFINES //
/////////////
#define NUM_LIGHTS 3


/////////////
// GLOBALS //
/////////////
Texture2D shaderTexture;
SamplerState SampleType;

cbuffer LightBuffer
{
	float4 ambientColor;
	float4 diffuseColor;
    float3 lightDirection;
	float specularPower;
    float4 specularColor;

	bool ambientColorState;
	bool diffuseColorState;
	bool specularColorState;
	float padding;
};

cbuffer LightColorBuffer
{
	float4 pointDiffuseColor[NUM_LIGHTS];
};

//////////////
// TYPEDEFS //
//////////////
struct PixelInputType
{
    float4 position : SV_POSITION;
    float2 tex : TEXCOORD0;
	float3 normal : NORMAL;

    float3 lightPos1 : TEXCOORD1;
    float3 lightPos2 : TEXCOORD2;
    float3 lightPos3 : TEXCOORD3;
    float3 lightPos4 : TEXCOORD4;
    float3 lightPos5 : TEXCOORD5;
    float3 lightPos6 : TEXCOORD6;

	float3 viewDirection : TEXCOORD7;
};


////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
float4 LightPixelShader(PixelInputType input) : SV_TARGET
{
	float4 textureColor;

	float3 lightDir;
	float directionLightIntensity;
	float4 directionColor;
	float3 reflection;
    float4 specular;

	float pointLightIntensity1, pointLightIntensity2, pointLightIntensity3, pointLightIntensity4, pointLightIntensity5, pointLightIntensity6;
	float4 pointLightColor1, pointLightColor2, pointLightColor3;

	float4 pointLightColor;
	float4 finalcolor;


	// Sample the pixel color from the texture using the sampler at this texture coordinate location.
	textureColor = shaderTexture.Sample(SampleType, input.tex);

	if(textureColor.a == 0) return textureColor; // billboard 모델 투명한 부분 랜더링 X





	////////////////////////////////////////////////////////////////////////////////////////////////////// pointLight

    // Calculate the different amounts of light on this pixel based on the positions of the lights.
	pointLightIntensity1 = saturate(dot(input.normal, input.lightPos1));
	pointLightIntensity2 = saturate(dot(input.normal, input.lightPos2));
	pointLightIntensity3 = saturate(dot(input.normal, input.lightPos3));
	
	// Determine the diffuse color amount of each of the four lights.
	pointLightColor1 = pointDiffuseColor[0] * pointLightIntensity1;
	pointLightColor2 = pointDiffuseColor[1] * pointLightIntensity2;
	pointLightColor3 = pointDiffuseColor[2] * pointLightIntensity3;

	// + pointLightColor2 + pointLightColor3 + pointLightColor4 + pointLightColor5 + pointLightColor6

	// Multiply the texture pixel by the combination of all four light colors to get the final result.
	pointLightColor = saturate(pointLightColor1 + pointLightColor2 + pointLightColor3) * textureColor;

	////////////////////////////////////////////////////////////////////////////////////////////////////// pointLight








	// Set the default output color to the ambient light value for all pixels.
	if(ambientColorState)
	{
		directionColor = ambientColor;
	}
	else
	{
		directionColor = float4(0.0f, 0.0f, 0.0f, 0.0f);
	}

	// Initialize the specular color.
	specular = float4(0.0f, 0.0f, 0.0f, 0.0f);

	// Invert the light direction for calculations.
    lightDir = -lightDirection;

    // Calculate the amount of light on this pixel.
    directionLightIntensity = saturate(dot(input.normal, lightDir));

	if(directionLightIntensity > 0.0f)
    {
		
		if(diffuseColorState == true)
		{
			//directionLightIntensity = ceil(directionLightIntensity * 5) / 5.0f;

			// Determine the final diffuse color based on the diffuse color and the amount of light intensity.
			directionColor += (diffuseColor * directionLightIntensity);
		}

		// Saturate the ambient and diffuse color.
		directionColor = saturate(directionColor);

		// Calculate the reflection vector based on the light intensity, normal vector, and light direction.
        reflection = normalize(2 * directionLightIntensity * input.normal - lightDir); 

		// Determine the amount of specular light based on the reflection vector, viewing direction, and specular power.
        specular = pow(saturate(dot(reflection, input.viewDirection)), specularPower);
    }

 	directionColor = directionColor * textureColor;

	if(specularColorState == true)
	{
		directionColor = saturate(directionColor + specular);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////// finalcolor

	finalcolor = pointLightColor + directionColor;

    return finalcolor;
}